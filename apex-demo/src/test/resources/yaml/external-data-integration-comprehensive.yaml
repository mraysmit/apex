# ============================================================================
# APEX YAML Configuration File
# ============================================================================
# Used by: ORPHANED - No Java test currently uses this file
# Purpose: Comprehensive external data integration demonstration with multiple data
#          sources including CSV files, JSON files, and database connections for
#          testing APEX external data integration capabilities
# Status: Available for integration with comprehensive external data integration tests
# ============================================================================

metadata:
  id: "external-data-integration-comprehensive"
  name: "External Data Integration Comprehensive Configuration"
  version: "1.0.0"
  description: "Comprehensive external data integration with multiple data sources: databases, REST APIs, file systems, and message queues"
  type: "external-data-config"
  author: "apex-business-tests"
  business-domain: "Data Integration"
  tags: ["external-data", "integration", "multi-source", "real-time-data"]

# Comprehensive external data sources configuration
dataSources:
  # 1. Primary trading database - PostgreSQL
  - name: "trading-database"
    type: "database"
    sourceType: "postgresql"
    enabled: true
    description: "Primary trading system database with real-time trade data"
    
    connection:
      host: "trading-db.internal.company.com"
      port: 5432
      database: "trading_system"
      username: "apex_integration_user"
      password: "${TRADING_DB_PASSWORD}"
      connectionPool:
        minSize: 5
        maxSize: 20
        maxWaitTime: 30000
        
    queries:
      # Real-time trade queries
      getTradeById: |
        SELECT t.trade_id, t.instrument_id, t.counterparty_id, t.quantity, t.price, 
               t.trade_date, t.settlement_date, t.trader_id, t.book_id, t.status,
               i.instrument_type, i.currency, i.maturity_date,
               c.counterparty_name, c.lei, c.credit_rating
        FROM trades t
        JOIN instruments i ON t.instrument_id = i.instrument_id
        JOIN counterparties c ON t.counterparty_id = c.counterparty_id
        WHERE t.trade_id = :tradeId
        
      getTradesToday: |
        SELECT * FROM trades 
        WHERE DATE(trade_date) = CURRENT_DATE 
        AND status IN ('EXECUTED', 'SETTLED')
        ORDER BY trade_date DESC
        
      getPositionsByBook: |
        SELECT book_id, instrument_id, SUM(quantity) as net_position, 
               AVG(price) as avg_price, COUNT(*) as trade_count
        FROM trades 
        WHERE book_id = :bookId AND status = 'EXECUTED'
        GROUP BY book_id, instrument_id
        
    cache:
      enabled: true
      ttlSeconds: 300
      maxSize: 10000
      evictionPolicy: "LRU"
      
    healthCheck:
      enabled: true
      query: "SELECT 1"
      intervalSeconds: 60
      timeoutSeconds: 10

  # 2. Market data REST API - Real-time pricing
  - name: "market-data-api"
    type: "rest-api"
    enabled: true
    description: "Real-time market data API for instrument pricing and market information"
    
    connection:
      baseUrl: "https://api.marketdata.com/v2"
      timeout: 15000
      retryAttempts: 3
      retryDelay: 1000
      
      authentication:
        type: "api-key"
        apiKey: "${MARKET_DATA_API_KEY}"
        headerName: "X-API-Key"
        
      headers:
        Content-Type: "application/json"
        Accept: "application/json"
        User-Agent: "APEX-Integration/1.0"
        
    endpoints:
      # Real-time price endpoints
      getCurrentPrice: |
        GET /instruments/:instrumentId/price
        Response: {
          "instrumentId": "string",
          "price": "number",
          "currency": "string",
          "timestamp": "datetime",
          "bid": "number",
          "ask": "number",
          "volume": "number"
        }
        
      getHistoricalPrices: |
        GET /instruments/:instrumentId/history?from=:fromDate&to=:toDate
        Response: [{
          "date": "date",
          "open": "number",
          "high": "number", 
          "low": "number",
          "close": "number",
          "volume": "number"
        }]
        
      getMarketStatus: |
        GET /markets/:marketId/status
        Response: {
          "marketId": "string",
          "status": "OPEN|CLOSED|PRE_OPEN|POST_CLOSE",
          "nextOpen": "datetime",
          "nextClose": "datetime"
        }
        
    cache:
      enabled: true
      ttlSeconds: 60  # 1 minute for real-time data
      maxSize: 50000
      
    rateLimiting:
      enabled: true
      requestsPerSecond: 100
      burstSize: 200

  # 3. Reference data file system - CSV and JSON files
  - name: "reference-data-files"
    type: "file-system"
    enabled: true
    description: "Reference data files including counterparty information, instrument master data"
    
    connection:
      basePath: "/data/reference"
      filePattern: "*.{csv,json}"
      watchForChanges: true
      
    fileFormats:
      - type: "csv"
        hasHeaderRow: true
        delimiter: ","
        encoding: "UTF-8"
        dateFormat: "yyyy-MM-dd"
        
      - type: "json"
        encoding: "UTF-8"
        prettyPrint: false
        
    files:
      counterparties: |
        File: counterparties.csv
        Columns: counterparty_id,name,lei,jurisdiction,entity_type,credit_rating,established_date
        
      instruments: |
        File: instruments.json
        Structure: {
          "instruments": [{
            "instrumentId": "string",
            "isin": "string", 
            "instrumentType": "string",
            "currency": "string",
            "maturityDate": "date",
            "issuer": "string",
            "couponRate": "number"
          }]
        }
        
      currencies: |
        File: currencies.csv
        Columns: currency_code,currency_name,symbol,decimal_places,is_base_currency
        
    monitoring:
      enabled: true
      checkInterval: 300  # 5 minutes
      alertOnChanges: true

  # 4. Risk calculation service - Internal microservice
  - name: "risk-calculation-service"
    type: "rest-api"
    enabled: true
    description: "Internal risk calculation microservice for VaR, stress testing, and limit monitoring"
    
    connection:
      baseUrl: "http://risk-service.internal:8080/api/v1"
      timeout: 30000
      
      authentication:
        type: "oauth2"
        clientId: "${RISK_SERVICE_CLIENT_ID}"
        clientSecret: "${RISK_SERVICE_CLIENT_SECRET}"
        tokenUrl: "http://auth-service.internal:8080/oauth/token"
        
    endpoints:
      calculatePortfolioVaR: |
        POST /risk/var/portfolio
        Request: {
          "portfolioId": "string",
          "confidenceLevel": "number",
          "holdingPeriod": "number",
          "method": "HISTORICAL_SIMULATION|MONTE_CARLO|PARAMETRIC"
        }
        Response: {
          "portfolioId": "string",
          "var": "number",
          "currency": "string",
          "calculationDate": "datetime",
          "method": "string"
        }
        
      calculateCounterpartyExposure: |
        POST /risk/exposure/counterparty
        Request: {
          "counterpartyId": "string",
          "includeCollateral": "boolean",
          "includePotentialExposure": "boolean"
        }
        Response: {
          "counterpartyId": "string",
          "currentExposure": "number",
          "potentialExposure": "number",
          "netExposure": "number",
          "currency": "string"
        }
        
    cache:
      enabled: true
      ttlSeconds: 1800  # 30 minutes for risk calculations
      maxSize: 1000

  # 5. Regulatory reporting message queue - Apache Kafka
  - name: "regulatory-reporting-queue"
    type: "message-queue"
    sourceType: "kafka"
    enabled: true
    description: "Kafka message queue for regulatory reporting events and notifications"
    
    connection:
      brokers: ["kafka-1.internal:9092", "kafka-2.internal:9092", "kafka-3.internal:9092"]
      securityProtocol: "SASL_SSL"
      saslMechanism: "PLAIN"
      username: "${KAFKA_USERNAME}"
      password: "${KAFKA_PASSWORD}"
      
    topics:
      tradeReporting: |
        Topic: trade-reporting-events
        Partition: 3
        Replication: 2
        Message Format: {
          "eventType": "TRADE_EXECUTED|TRADE_SETTLED|TRADE_CANCELLED",
          "tradeId": "string",
          "timestamp": "datetime",
          "data": "object"
        }
        
      riskAlerts: |
        Topic: risk-alert-notifications
        Partition: 1
        Replication: 2
        Message Format: {
          "alertType": "LIMIT_BREACH|VAR_EXCEEDED|COUNTERPARTY_RISK",
          "severity": "LOW|MEDIUM|HIGH|CRITICAL",
          "message": "string",
          "timestamp": "datetime",
          "data": "object"
        }
        
    consumer:
      groupId: "apex-integration-consumer"
      autoOffsetReset: "latest"
      enableAutoCommit: true
      maxPollRecords: 100

  # 6. Audit and compliance database - MongoDB
  - name: "audit-compliance-database"
    type: "database"
    sourceType: "mongodb"
    enabled: true
    description: "MongoDB database for audit trails, compliance records, and regulatory submissions"
    
    connection:
      host: "mongodb-cluster.internal"
      port: 27017
      database: "compliance_audit"
      username: "apex_audit_user"
      password: "${MONGODB_PASSWORD}"
      authDatabase: "admin"
      
    collections:
      auditTrail: |
        Collection: audit_trail
        Schema: {
          "_id": "ObjectId",
          "eventType": "string",
          "userId": "string", 
          "timestamp": "datetime",
          "action": "string",
          "entityType": "string",
          "entityId": "string",
          "changes": "object",
          "ipAddress": "string"
        }
        
      regulatorySubmissions: |
        Collection: regulatory_submissions
        Schema: {
          "_id": "ObjectId",
          "submissionType": "string",
          "regulator": "string",
          "submissionDate": "datetime",
          "reportingPeriod": "string",
          "status": "string",
          "data": "object",
          "confirmationNumber": "string"
        }
        
    queries:
      getAuditTrailByUser: |
        db.audit_trail.find({"userId": ":userId", "timestamp": {"$gte": ":fromDate", "$lte": ":toDate"}})
        
      getSubmissionsByPeriod: |
        db.regulatory_submissions.find({"reportingPeriod": ":period", "status": "SUBMITTED"})

# Global configuration settings
configuration:
  # Connection pooling settings
  connectionPooling:
    enabled: true
    defaultMinSize: 2
    defaultMaxSize: 10
    defaultMaxWaitTime: 30000
    
  # Retry and circuit breaker settings
  resilience:
    retryAttempts: 3
    retryDelay: 1000
    circuitBreakerThreshold: 5
    circuitBreakerTimeout: 60000
    
  # Monitoring and health checks
  monitoring:
    enabled: true
    healthCheckInterval: 60
    metricsCollection: true
    alerting:
      enabled: true
      errorThreshold: 10
      latencyThreshold: 5000
