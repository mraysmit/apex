# ============================================================================
# APEX YAML Configuration File
# ============================================================================
# Used by: DESIGN PROPOSAL - No Java test currently uses this file
# Purpose: Introduce new "conditional-mapping-enrichment" type
#          Purpose-built for conditional field mapping, most intuitive
# Status: Phase 3 functionality - Not implemented yet
# ============================================================================

metadata:
  id: "conditional-mapping-design-v3"
  name: "New Conditional Mapping Enrichment - FX Transaction"
  version: "2.0.0"
  description: "New enrichment type for conditional field mapping"
  type: "scenario"
  author: "APEX Enhancement Team"
  created: "2025-09-17"

# External data-source references
data-source-refs:
  - name: "translation-db"
    source: "database-h2.yaml"
    enabled: true

enrichments:
  # Currency ranking (unchanged)
  - id: "enrich-currency-ranks"
    type: "lookup-enrichment"
    condition: "#BUY_CURRENCY != null"
    lookup-config:
      lookup-key: "#BUY_CURRENCY"
      lookup-dataset:
        type: "database"
        data-source-ref: "translation-db"
        query-ref: "getCurrencyRank"
    field-mappings:
      - source-field: "currency_rank"
        target-field: "BUY_CURRENCY_RANK"

  # NEW ENRICHMENT TYPE: conditional-mapping-enrichment
  - id: "conditional-ndf-mapping"
    type: "conditional-mapping-enrichment"  # NEW TYPE
    name: "Conditional NDF Field Mapping"
    description: "Dynamic field mapping based on multiple conditions"
    enabled: true
    
    # Target field to be conditionally mapped
    target-field: "IS_NDF"
    
    # Conditional mapping rules with OR logic
    mapping-rules:
      # Rule 1: Direct mapping for SWIFT with valid values
      - id: "swift-direct-mapping"
        name: "SWIFT Direct Mapping"
        priority: 1
        conditions:
          operator: "OR"
          rules:
            - "({'0', '1'}.contains(#IS_NDF)) && (#SYSTEM_CODE == 'SWIFT')"
            - "#IS_NDF == 'Y' && #SYSTEM_CODE == 'SWIFT'"
        mapping:
          type: "direct"
          source-field: "IS_NDF"
          transformation: "#IS_NDF"  # Keep original value
          
      # Rule 2: Database translation mapping
      - id: "database-translation-mapping"
        name: "Database Translation Mapping"
        priority: 2
        conditions:
          operator: "AND"
          rules:
            - "#IS_NDF != null"
            - "#SYSTEM_CODE == 'SWIFT'"
            - "!({'0', '1', 'Y'}.contains(#IS_NDF))"
        mapping:
          type: "lookup"
          lookup-config:
            lookup-dataset:
              type: "database"
              data-source-ref: "translation-db"
              query-ref: "getInternalCodeWithoutSubcode"
              parameters:
                - field: "TRANSLATION_TYPE"
                  value: "'IS_NDF'"
                - field: "CLIENT_CODE"
                - field: "SYSTEM_CODE"
                - field: "EXTERNAL_CODE"
                  value: "#IS_NDF"
          transformation: "#lookup.internal_code"
          fallback-value: "#IS_NDF"  # Use original if lookup fails
          
      # Rule 3: Default mapping (catch-all)
      - id: "default-mapping"
        name: "Default Mapping"
        priority: 999  # Lowest priority
        conditions:
          default: true  # Always matches if no other rules match
        mapping:
          type: "direct"
          source-field: "IS_NDF"
          transformation: "#IS_NDF"
          
    # Optional: Execution settings
    execution-settings:
      stop-on-first-match: true  # Stop after first matching rule
      log-matched-rule: true     # Log which rule was applied
      validate-result: true      # Validate final mapped value
