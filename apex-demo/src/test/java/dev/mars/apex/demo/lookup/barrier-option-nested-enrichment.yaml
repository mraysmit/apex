# APEX Nested Data Processing Validation Configuration
# Validates APEX enrichment engine can handle complex nested XML structures

metadata:
  id: "barrier-option-nested-enrichment"
  name: "APEX Nested Data Processing Validation"
  version: "1.0.0"
  description: "Validates APEX enrichment engine nested data processing capabilities"
  type: "enrichment"
  business-domain: "Financial Derivatives - Barrier Options"
  author: "apex.validation.team@company.com"
  created-date: "2025-09-19"
  tags: ["apex-validation", "nested-data", "barrier-options", "enrichment"]

# APEX Enrichment Rules - All processing logic defined here
# STEP 4 VERSION: 4 enrichments including nested date calculations
enrichments:
  # VALIDATES: APEX can navigate 2-level nested structures
  - id: "apex-level2-navigation"
    name: "APEX Level 2 Nested Field Navigation"
    description: "Validates APEX can extract underlyingAsset['marketData']['currentPrice']"
    type: "calculation-enrichment"
    condition: "#underlyingAsset != null && #underlyingAsset['marketData'] != null && #underlyingAsset['marketData']['currentPrice'] != null"
    calculation-config:
      expression: "#underlyingAsset['marketData']['currentPrice']"
      result-field: "apexExtractedMarketPrice"
    field-mappings:
      - source-field: "apexExtractedMarketPrice"
        target-field: "apexExtractedMarketPrice"
    priority: 1
    categories: ["nested-navigation", "level-2"]
    
  # VALIDATES: APEX can perform cross-nested-field business calculations
  - id: "apex-cross-nested-calculation"
    name: "APEX Cross-Nested Business Calculation"
    description: "Validates APEX can calculate barrier spread across nested structures"
    type: "calculation-enrichment"
    condition: "#barrierTerms != null && #barrierTerms['barrierLevel'] != null && #pricingTerms != null && #pricingTerms['strikePrice'] != null"
    calculation-config:
      expression: "T(java.lang.Double).parseDouble(#barrierTerms['barrierLevel']) - T(java.lang.Double).parseDouble(#pricingTerms['strikePrice'])"
      result-field: "apexBarrierSpread"
    field-mappings:
      - source-field: "apexBarrierSpread"
        target-field: "apexBarrierSpread"
    priority: 2
    categories: ["business-calculation", "cross-nested"]

  # VALIDATES: APEX can process 3-level deeply nested conditional logic
  - id: "apex-level3-conditional"
    name: "APEX Level 3 Nested Conditional Processing"
    description: "Validates APEX can process barrierTerms.knockoutConditions.rebateTerms logic"
    type: "calculation-enrichment"
    condition: "#barrierTerms != null && #barrierTerms['knockoutConditions'] != null && #barrierTerms['knockoutConditions']['rebateTerms'] != null && #barrierTerms['knockoutConditions']['rebateTerms']['rebateAmount'] != null && #pricingTerms != null && #pricingTerms['premium'] != null"
    calculation-config:
      expression: "(T(java.lang.Double).parseDouble(#barrierTerms['knockoutConditions']['rebateTerms']['rebateAmount']) / T(java.lang.Double).parseDouble(#pricingTerms['premium'])) * 100"
      result-field: "apexRebatePercentage"
    field-mappings:
      - source-field: "apexRebatePercentage"
        target-field: "apexRebatePercentage"
    priority: 3
    categories: ["level-3-nested", "conditional-logic", "percentage-calculation"]

  # VALIDATES: APEX can handle complex nested date calculations with SpEL
  - id: "apex-nested-date-calculation"
    name: "APEX Nested Date Calculation with SpEL"
    description: "Validates APEX can calculate days between nested observation period dates"
    type: "calculation-enrichment"
    condition: "#barrierTerms != null && #barrierTerms['knockoutConditions'] != null && #barrierTerms['knockoutConditions']['observationPeriod'] != null && #barrierTerms['knockoutConditions']['observationPeriod']['startDate'] != null && #barrierTerms['knockoutConditions']['observationPeriod']['endDate'] != null"
    calculation-config:
      expression: "T(java.time.temporal.ChronoUnit).DAYS.between(T(java.time.LocalDate).parse(#barrierTerms['knockoutConditions']['observationPeriod']['startDate']), T(java.time.LocalDate).parse(#barrierTerms['knockoutConditions']['observationPeriod']['endDate']))"
      result-field: "apexObservationPeriodDays"
    field-mappings:
      - source-field: "apexObservationPeriodDays"
        target-field: "apexObservationPeriodDays"
    priority: 4
    categories: ["date-calculation", "spel-integration", "level-3-nested"]

# Processing Configuration
processing:
  continue-on-error: false
  max-errors: 0
  error-handling: "fail-fast"
