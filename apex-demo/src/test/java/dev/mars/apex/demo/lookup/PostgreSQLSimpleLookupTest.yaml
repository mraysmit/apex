# PostgreSQL Simple Lookup Configuration
# Demonstrates real PostgreSQL database integration using Testcontainers
# Use Case: Customer profile data source for enrichment lookups with real PostgreSQL

# ============================================================================
# APEX YAML Configuration File
# ============================================================================
# Used by: PostgreSQLSimpleLookupTest.java (Phase 1.1 implementation)
# Purpose: PostgreSQL simple lookup demonstration using APEX lookup enrichments
#          with real PostgreSQL database integration and simple lookup operations
# Status: ACTIVE - Integrated with PostgreSQL simple lookup tests
# ============================================================================

metadata:
  id: "postgresql-simple-lookup-demo"
  name: "PostgreSQL Simple Lookup Demo"
  version: "2.0.0"
  description: "Data source configuration for real PostgreSQL database with Testcontainers integration"
  type: "enrichment"
  author: "apex.demo.team@company.com"
  created-date: "2024-12-24"
  updated-date: "2025-09-20"
  tags: ["apex-demo", "lookup", "postgresql", "testcontainers", "phase-1"]

# PostgreSQL data source configuration (will be updated by test with real connection details)
data-sources:
  - name: "postgresql-customer-database"
    type: "database"
    source-type: "postgresql"
    enabled: true
    description: "Customer master data from real PostgreSQL database via Testcontainers"

    connection:
      # PostgreSQL connection details (will be dynamically updated by test)
      # These are placeholder values - test will inject real Testcontainers connection
      database: "apex_test"
      username: "apex_user"
      password: "apex_pass"
      host: "localhost"
      port: 5432

      # PostgreSQL-optimized connection pool configuration
      connection-pool:
        max-size: 10
        min-size: 2
        initial-size: 2
        connection-timeout: 30000
        idle-timeout: 600000
        max-lifetime: 1800000
        leak-detection-threshold: 60000
        connection-test-query: "SELECT 1"
        test-on-borrow: true
        test-while-idle: true
        validation-timeout: 5000

    # PostgreSQL-optimized caching configuration
    cache:
      enabled: true
      ttlSeconds: 1800  # 30 minutes cache for PostgreSQL
      maxSize: 5000
      eviction-policy: "LRU"
      statistics-enabled: true

    # PostgreSQL health check configuration
    healthCheck:
      enabled: true
      query: "SELECT 1"
      intervalSeconds: 60
      timeoutSeconds: 10

    # PostgreSQL query definitions (no initialization - handled by Testcontainers)
    queries:
      customerProfile: |
        SELECT
          customer_id,
          customer_name,
          customer_type,
          tier,
          region,
          status,
          created_date,
          last_updated,
          metadata,
          tags
        FROM customers
        WHERE customer_id = :customerId

      customerSummary: |
        SELECT
          customer_id,
          customer_name,
          customer_type,
          tier,
          region,
          status,
          EXTRACT(YEAR FROM created_date) as creation_year,
          CASE
            WHEN metadata->>'revenue' IS NOT NULL THEN (metadata->>'revenue')::BIGINT
            WHEN metadata->>'aum' IS NOT NULL THEN (metadata->>'aum')::BIGINT
            ELSE 0
          END as financial_value
        FROM customers
        WHERE customer_id = :customerId

    # Parameter definitions
    parameterNames:
      - "customerId"

# PostgreSQL enrichment rules using real database lookups
enrichments:
  - id: "postgresql-simple-lookup-demo"
    name: "PostgreSQL Customer Profile Lookup"
    description: "Simple customer profile lookup using real PostgreSQL database via Testcontainers"
    type: "lookup-enrichment"
    enabled: true
    priority: 10

    # Condition: Only process if customerId is present
    condition: "#customerId != null && #customerId != ''"

    # PostgreSQL database lookup configuration
    lookup-config:
      lookup-key: "#customerId"
      lookup-dataset:
        type: "database"
        connection-name: "postgresql-customer-database"
        query: "SELECT customer_name, customer_type, tier, region, status, created_date, metadata, tags FROM customers WHERE customer_id = :customerId"
        parameters:
          - field: "customerId"
            type: "string"

        # PostgreSQL-specific caching
        cache-enabled: true
        cache-ttl-seconds: 900  # 15 minutes for individual lookups

    # Field mappings for enrichment results (PostgreSQL returns lowercase column names)
    field-mappings:
      - source-field: "customer_name"
        target-field: "customerName"
        required: true
      - source-field: "customer_type"
        target-field: "customerType"
        required: true
      - source-field: "tier"
        target-field: "customerTier"
        required: true
      - source-field: "region"
        target-field: "customerRegion"
        required: true
      - source-field: "status"
        target-field: "customerStatus"
        required: true
      - source-field: "created_date"
        target-field: "customerCreatedDate"
        required: false
      - source-field: "metadata"
        target-field: "customerMetadata"
        required: false
      - source-field: "tags"
        target-field: "customerTags"
        required: false

  # Additional enrichment for testing PostgreSQL JSON features
  - id: "postgresql-json-enrichment"
    name: "PostgreSQL JSON Metadata Enrichment"
    description: "Extract specific fields from PostgreSQL JSONB metadata column"
    type: "lookup-enrichment"
    enabled: true
    priority: 20

    condition: "#customerId != null && #customerMetadata != null"

    lookup-config:
      lookup-key: "#customerId"
      lookup-dataset:
        type: "database"
        connection-name: "postgresql-customer-database"
        query: |
          SELECT
            metadata->>'industry' as industry,
            metadata->>'employees' as employee_count,
            COALESCE(metadata->>'revenue', metadata->>'aum') as financial_value,
            array_to_string(tags, ',') as tag_list
          FROM customers
          WHERE customer_id = :customerId
        parameters:
          - field: "customerId"
            type: "string"

    field-mappings:
      - source-field: "industry"
        target-field: "customerIndustry"
        required: false
      - source-field: "employee_count"
        target-field: "customerEmployeeCount"
        required: false
        transformation: "#value != null ? T(java.lang.Integer).parseInt(#value.toString()) : 0"
      - source-field: "financial_value"
        target-field: "customerFinancialValue"
        required: false
        transformation: "#value != null ? T(java.lang.Long).parseLong(#value.toString()) : 0L"
      - source-field: "tag_list"
        target-field: "customerTagList"
        required: false