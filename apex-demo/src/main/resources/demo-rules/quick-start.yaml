# ============================================================================
# APEX Rules Engine - Quick Start Configuration
# ============================================================================
#
# This YAML configuration provides a simple, easy-to-understand introduction
# to the APEX Rules Engine. It demonstrates basic validation rules and
# enrichment capabilities using customer data as an example.
#
# PURPOSE:
# This configuration is designed for developers who are new to the APEX Rules
# Engine and want to quickly understand how to create and configure rules
# using YAML. It serves as a foundation for more complex rule configurations.
#
# LEARNING OBJECTIVES:
# 1. Understand basic rule structure and syntax
# 2. Learn how to write SpEL (Spring Expression Language) conditions
# 3. See how validation rules work with real data
# 4. Explore basic enrichment capabilities with lookup datasets
# 5. Understand rule priorities and execution order
#
# DEMO SCENARIOS:
# - Customer onboarding validation
# - Basic data quality checks
# - Status code enrichment with lookup tables
# - Simple business rule enforcement
#
# CONFIGURATION FEATURES:
# - Simple validation rules for common use cases
# - Clear, readable SpEL expressions
# - Descriptive rule names and messages
# - Basic enrichment with inline lookup data
# - Priority-based rule execution
#
# USAGE:
# This configuration is used by:
# - QuickStartDemo.java - 5-minute introduction to the rules engine
# - YamlDatasetDemo.java - YAML configuration demonstration
# - New developer onboarding and training
# - Rule engine proof-of-concept implementations
#
# NEXT STEPS:
# After mastering this configuration, explore:
# - file-processing-rules.yaml for advanced validation and enrichment
# - batch-processing.yaml for high-performance scenarios
# - financial-validation-rules.yaml for industry-specific examples
#
# ============================================================================

metadata:
  name: "Customer Validation Rules"
  version: "1.0.0"
  description: "Quick start example rules for customer validation"
  created-by: "demo@rulesengine.dev"
  created-date: "2025-07-27"

# ============================================================================
# BASIC VALIDATION RULES
# ============================================================================
#
# These rules demonstrate fundamental validation concepts using simple,
# easy-to-understand SpEL expressions. Each rule validates a specific
# aspect of customer data.
#
# RULE STRUCTURE:
# - id: Unique identifier for the rule
# - name: Human-readable name for the rule
# - condition: SpEL expression that evaluates to true/false
# - message: Error message displayed when validation fails
# - description: Detailed explanation of the rule's purpose
# - priority: Execution order (lower numbers execute first)
#
# SPEL EXPRESSION BASICS:
# - #data.fieldName: Accesses a field in the data object
# - != null: Checks if a value is not null
# - >= 18: Numeric comparison
# - .contains('@'): String method call
# - .length() > 0: String length validation
#
# VALIDATION PATTERNS:
# - Required field validation (null checks)
# - Format validation (email contains @)
# - Range validation (age >= 18)
# - Length validation (name not empty)
#
rules:
  - id: "age-check"
    name: "Age Validation"
    condition: "#data.age >= 18"
    message: "Customer must be at least 18 years old"
    description: "Validates that customer meets minimum age requirement"
    priority: 1
    
  - id: "email-check"
    name: "Email Validation"
    condition: "#data.email != null && #data.email.contains('@')"
    message: "Valid email address is required"
    description: "Ensures customer has a valid email address format"
    priority: 2
    
  - id: "name-check"
    name: "Name Validation"
    condition: "#data.name != null && #data.name.length() > 0"
    message: "Customer name is required"
    description: "Validates that customer name is provided"
    priority: 3

# ============================================================================
# BASIC ENRICHMENT CONFIGURATION
# ============================================================================
#
# This section demonstrates how to enrich data using lookup tables.
# Enrichment adds additional information to your data based on existing values.
#
# ENRICHMENT CONCEPTS:
# - lookup-enrichment: Adds data by looking up values in a reference dataset
# - condition: SpEL expression that determines when to apply enrichment
# - lookup-dataset: The reference data used for lookups
# - field-mappings: How to map lookup results to target fields
#
# LOOKUP DATASET FEATURES:
# - type: "inline" means data is embedded in this configuration
# - key-field: The field used to match against your data
# - data: Array of lookup records with key-value pairs
#
# FIELD MAPPING:
# - source-field: Field name in the lookup dataset
# - target-field: Field name to add to your data
#
# EXAMPLE SCENARIO:
# This enrichment converts status codes (A, I, P) into human-readable
# status names and descriptions, making data more meaningful for users.
#
enrichments:
  - id: "status-enrichment"
    type: "lookup-enrichment"
    condition: "['statusCode'] != null"
    lookup-config:
      lookup-dataset:
        type: "inline"
        key-field: "code"
        data:
          - code: "A"
            name: "Active"
            description: "Active customer"
          - code: "I"
            name: "Inactive"
            description: "Inactive customer"
          - code: "P"
            name: "Pending"
            description: "Pending approval"
    field-mappings:
      - source-field: "name"
        target-field: "statusName"
      - source-field: "description"
        target-field: "statusDescription"
