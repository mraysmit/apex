# APEX Performance Monitoring Patterns Configuration
# External data source configuration for performance monitoring patterns
# Replaces hardcoded performance monitoring logic from PerformanceAndExceptionDemo

type: "external-data-config"
name: "performance-monitoring-patterns-config"
description: "Data-driven performance monitoring patterns configuration for performance and exception handling processing"

# Performance monitoring patterns configuration by pattern type
data:
  execution-time-monitoring-patterns:
    pattern-type: "execution-time-monitoring-patterns"
    pattern-name: "Execution Time Monitoring Patterns"
    description: "Patterns for monitoring rule execution time"
    pattern-characteristics:
      monitoring-focus: "EXECUTION_TIME"
      measurement-precision: "NANOSECOND"
      aggregation-strategy: "STATISTICAL"
    monitoring-patterns:
      basic-timing-pattern:
        pattern-id: "BASIC_TIMING_PATTERN"
        pattern-name: "Basic Timing Monitoring Pattern"
        pattern-description: "Basic pattern for measuring rule execution time"
        timing-metrics:
          start-time-capture: "System.nanoTime()"
          end-time-capture: "System.nanoTime()"
          duration-calculation: "endTime - startTime"
          precision: "NANOSECOND"
        measurement-points:
          - point-name: "rule-start"
            point-description: "Rule execution start"
            capture-method: "TIMESTAMP"
          - point-name: "rule-end"
            point-description: "Rule execution end"
            capture-method: "TIMESTAMP"
          - point-name: "duration"
            point-description: "Total execution duration"
            capture-method: "CALCULATED"
        aggregation-methods:
          - method-name: "average"
            method-description: "Average execution time"
            calculation: "sum / count"
          - method-name: "minimum"
            method-description: "Minimum execution time"
            calculation: "min(values)"
          - method-name: "maximum"
            method-description: "Maximum execution time"
            calculation: "max(values)"
          - method-name: "percentile-95"
            method-description: "95th percentile execution time"
            calculation: "percentile(values, 0.95)"
        audit-requirements:
          - "Log timing measurements"
          - "Track performance trends"
          
      advanced-timing-pattern:
        pattern-id: "ADVANCED_TIMING_PATTERN"
        pattern-name: "Advanced Timing Monitoring Pattern"
        pattern-description: "Advanced pattern with detailed timing breakdown"
        timing-metrics:
          compilation-time: "Expression compilation duration"
          evaluation-time: "Expression evaluation duration"
          total-time: "Total processing duration"
          overhead-time: "Monitoring overhead duration"
        measurement-points:
          - point-name: "compilation-start"
            point-description: "Expression compilation start"
            capture-method: "TIMESTAMP"
          - point-name: "compilation-end"
            point-description: "Expression compilation end"
            capture-method: "TIMESTAMP"
          - point-name: "evaluation-start"
            point-description: "Expression evaluation start"
            capture-method: "TIMESTAMP"
          - point-name: "evaluation-end"
            point-description: "Expression evaluation end"
            capture-method: "TIMESTAMP"
        performance-analysis:
          compilation-ratio: "compilation-time / total-time"
          evaluation-ratio: "evaluation-time / total-time"
          overhead-ratio: "overhead-time / total-time"
          efficiency-score: "evaluation-time / total-time"
        audit-requirements:
          - "Log detailed timing breakdown"
          - "Track performance component analysis"
          
      trend-analysis-pattern:
        pattern-id: "TREND_ANALYSIS_PATTERN"
        pattern-name: "Trend Analysis Monitoring Pattern"
        pattern-description: "Pattern for analyzing performance trends over time"
        trend-metrics:
          moving-average: "Rolling average over time window"
          performance-slope: "Rate of performance change"
          variance-analysis: "Performance consistency measurement"
          anomaly-detection: "Outlier identification"
        time-windows:
          - window-name: "short-term"
            window-duration: "1-minute"
            sample-size: 100
          - window-name: "medium-term"
            window-duration: "5-minutes"
            sample-size: 500
          - window-name: "long-term"
            window-duration: "15-minutes"
            sample-size: 1500
        trend-indicators:
          - indicator-name: "performance-degradation"
            indicator-description: "Increasing execution times"
            threshold: "20% increase over baseline"
          - indicator-name: "performance-improvement"
            indicator-description: "Decreasing execution times"
            threshold: "15% decrease from baseline"
          - indicator-name: "performance-stability"
            indicator-description: "Consistent execution times"
            threshold: "5% variance from average"
        audit-requirements:
          - "Log trend analysis results"
          - "Track performance evolution"
    pattern-settings:
      timing-precision: "NANOSECOND"
      aggregation-frequency: "REAL_TIME"
      trend-analysis: true
    
  memory-usage-tracking-patterns:
    pattern-type: "memory-usage-tracking-patterns"
    pattern-name: "Memory Usage Tracking Patterns"
    description: "Patterns for monitoring memory usage during rule execution"
    pattern-characteristics:
      monitoring-focus: "MEMORY_USAGE"
      measurement-precision: "BYTE"
      tracking-strategy: "HEAP_ANALYSIS"
    monitoring-patterns:
      heap-memory-pattern:
        pattern-id: "HEAP_MEMORY_PATTERN"
        pattern-name: "Heap Memory Monitoring Pattern"
        pattern-description: "Pattern for monitoring heap memory usage"
        memory-metrics:
          heap-before: "Heap memory before rule execution"
          heap-after: "Heap memory after rule execution"
          heap-delta: "Memory allocation during execution"
          gc-impact: "Garbage collection impact"
        measurement-points:
          - point-name: "pre-execution-heap"
            point-description: "Heap state before execution"
            capture-method: "Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory()"
          - point-name: "post-execution-heap"
            point-description: "Heap state after execution"
            capture-method: "Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory()"
          - point-name: "memory-allocation"
            point-description: "Memory allocated during execution"
            capture-method: "post-heap - pre-heap"
        memory-analysis:
          allocation-rate: "Memory allocated per second"
          gc-frequency: "Garbage collection frequency"
          memory-efficiency: "Useful memory / total allocated"
          leak-detection: "Memory not released after execution"
        audit-requirements:
          - "Log memory usage patterns"
          - "Track allocation efficiency"
          
      object-allocation-pattern:
        pattern-id: "OBJECT_ALLOCATION_PATTERN"
        pattern-name: "Object Allocation Monitoring Pattern"
        pattern-description: "Pattern for monitoring object allocation during execution"
        allocation-metrics:
          object-count: "Number of objects allocated"
          object-size: "Total size of allocated objects"
          allocation-hotspots: "High-allocation code paths"
          temporary-objects: "Short-lived object allocations"
        tracking-methods:
          - method-name: "allocation-profiling"
            method-description: "Profile object allocations"
            implementation: "JVM allocation tracking"
          - method-name: "size-estimation"
            method-description: "Estimate object sizes"
            implementation: "Instrumentation-based sizing"
        optimization-opportunities:
          - opportunity-name: "object-pooling"
            opportunity-description: "Reuse frequently allocated objects"
            impact: "Reduce allocation overhead"
          - opportunity-name: "lazy-initialization"
            opportunity-description: "Defer object creation until needed"
            impact: "Reduce memory footprint"
        audit-requirements:
          - "Log allocation patterns"
          - "Track optimization opportunities"
    pattern-settings:
      memory-precision: "BYTE"
      allocation-tracking: true
      gc-monitoring: true
    
  concurrent-performance-analysis-patterns:
    pattern-type: "concurrent-performance-analysis-patterns"
    pattern-name: "Concurrent Performance Analysis Patterns"
    description: "Patterns for analyzing concurrent execution performance"
    pattern-characteristics:
      monitoring-focus: "CONCURRENCY"
      measurement-precision: "THREAD_LEVEL"
      analysis-strategy: "CONTENTION_ANALYSIS"
    monitoring-patterns:
      thread-contention-pattern:
        pattern-id: "THREAD_CONTENTION_PATTERN"
        pattern-name: "Thread Contention Analysis Pattern"
        pattern-description: "Pattern for analyzing thread contention during concurrent execution"
        contention-metrics:
          lock-wait-time: "Time spent waiting for locks"
          thread-blocking: "Thread blocking frequency"
          contention-points: "High-contention code sections"
          scalability-factor: "Performance scaling with thread count"
        measurement-techniques:
          - technique-name: "lock-monitoring"
            technique-description: "Monitor lock acquisition and release"
            implementation: "JVM lock monitoring"
          - technique-name: "thread-state-tracking"
            technique-description: "Track thread states over time"
            implementation: "Thread state sampling"
          - technique-name: "contention-profiling"
            technique-description: "Profile contention hotspots"
            implementation: "Contention-aware profiling"
        performance-indicators:
          - indicator-name: "linear-scalability"
            indicator-description: "Performance scales linearly with threads"
            measurement: "throughput-per-thread consistency"
          - indicator-name: "contention-bottleneck"
            indicator-description: "Performance limited by contention"
            measurement: "decreasing throughput-per-thread"
          - indicator-name: "optimal-concurrency"
            indicator-description: "Optimal thread count for performance"
            measurement: "maximum total throughput"
        audit-requirements:
          - "Log contention analysis results"
          - "Track scalability metrics"
          
      throughput-analysis-pattern:
        pattern-id: "THROUGHPUT_ANALYSIS_PATTERN"
        pattern-name: "Throughput Analysis Pattern"
        pattern-description: "Pattern for analyzing throughput in concurrent scenarios"
        throughput-metrics:
          operations-per-second: "Total operations completed per second"
          operations-per-thread: "Operations completed per thread per second"
          throughput-efficiency: "Actual throughput / theoretical maximum"
          throughput-consistency: "Variance in throughput measurements"
        analysis-dimensions:
          - dimension-name: "thread-count-scaling"
            dimension-description: "Throughput vs thread count"
            measurement-approach: "Vary thread count, measure throughput"
          - dimension-name: "load-scaling"
            dimension-description: "Throughput vs workload size"
            measurement-approach: "Vary workload, measure throughput"
          - dimension-name: "time-consistency"
            dimension-description: "Throughput consistency over time"
            measurement-approach: "Measure throughput over time windows"
        optimization-targets:
          - target-name: "maximum-throughput"
            target-description: "Achieve highest possible throughput"
            optimization-strategy: "Minimize contention, optimize algorithms"
          - target-name: "consistent-throughput"
            target-description: "Maintain consistent throughput"
            optimization-strategy: "Load balancing, resource management"
        audit-requirements:
          - "Log throughput analysis results"
          - "Track performance optimization"
    pattern-settings:
      concurrency-analysis: true
      scalability-testing: true
      contention-monitoring: true
    
  exception-rate-monitoring-patterns:
    pattern-type: "exception-rate-monitoring-patterns"
    pattern-name: "Exception Rate Monitoring Patterns"
    description: "Patterns for monitoring exception rates and error handling performance"
    pattern-characteristics:
      monitoring-focus: "EXCEPTION_RATES"
      measurement-precision: "EXCEPTION_COUNT"
      analysis-strategy: "ERROR_PATTERN_ANALYSIS"
    monitoring-patterns:
      exception-frequency-pattern:
        pattern-id: "EXCEPTION_FREQUENCY_PATTERN"
        pattern-name: "Exception Frequency Monitoring Pattern"
        pattern-description: "Pattern for monitoring exception frequency and types"
        exception-metrics:
          total-exceptions: "Total number of exceptions"
          exception-rate: "Exceptions per unit time"
          exception-types: "Distribution of exception types"
          recovery-success-rate: "Successful error recovery percentage"
        frequency-analysis:
          - analysis-name: "exception-type-distribution"
            analysis-description: "Distribution of different exception types"
            measurement: "Count by exception type"
          - analysis-name: "exception-timing-correlation"
            analysis-description: "Correlation between exceptions and execution time"
            measurement: "Exception rate vs performance"
          - analysis-name: "exception-pattern-detection"
            analysis-description: "Patterns in exception occurrence"
            measurement: "Temporal and contextual patterns"
        error-impact-analysis:
          performance-degradation: "Performance impact of exception handling"
          resource-consumption: "Resource usage during error recovery"
          user-experience-impact: "Impact on user-facing operations"
          system-stability: "Impact on overall system stability"
        audit-requirements:
          - "Log exception frequency patterns"
          - "Track error impact analysis"
          
      error-recovery-pattern:
        pattern-id: "ERROR_RECOVERY_PATTERN"
        pattern-name: "Error Recovery Performance Pattern"
        pattern-description: "Pattern for monitoring error recovery performance"
        recovery-metrics:
          recovery-time: "Time to recover from errors"
          recovery-success-rate: "Percentage of successful recoveries"
          fallback-effectiveness: "Effectiveness of fallback mechanisms"
          error-propagation-rate: "Rate of error propagation"
        recovery-strategies:
          - strategy-name: "immediate-retry"
            strategy-description: "Immediate retry on error"
            performance-impact: "Low latency, potential amplification"
          - strategy-name: "exponential-backoff"
            strategy-description: "Retry with exponential backoff"
            performance-impact: "Higher latency, better stability"
          - strategy-name: "circuit-breaker"
            strategy-description: "Circuit breaker pattern"
            performance-impact: "Fast failure, system protection"
          - strategy-name: "graceful-degradation"
            strategy-description: "Graceful service degradation"
            performance-impact: "Maintained availability, reduced functionality"
        recovery-effectiveness:
          full-recovery: "Complete recovery to normal operation"
          partial-recovery: "Partial functionality restoration"
          graceful-failure: "Controlled failure with minimal impact"
          cascading-failure: "Failure propagation to other components"
        audit-requirements:
          - "Log recovery performance metrics"
          - "Track recovery strategy effectiveness"
    pattern-settings:
      exception-tracking: true
      recovery-monitoring: true
      error-analysis: true
    
  default:
    pattern-type: "default"
    pattern-name: "Default Performance Monitoring Patterns"
    description: "Default performance monitoring pattern processing"
    monitoring-patterns:
      default-pattern:
        pattern-id: "DEFAULT_PATTERN"
        pattern-name: "Default Pattern"
        timing-metrics:
          basic-timing: "Basic execution time measurement"
    pattern-settings:
      monitoring-enabled: true

# Monitoring execution patterns
execution-patterns:
  performance-category-pattern:
    pattern-name: "Performance Category Pattern"
    description: "Monitor performance based on categories"
    performance-categories: ["EXECUTION_TIME", "MEMORY_USAGE", "CONCURRENCY", "EXCEPTION_HANDLING"]
    
  measurement-precision-pattern:
    pattern-name: "Measurement Precision Pattern"
    description: "Monitor performance with different precision levels"
    precision-levels: ["NANOSECOND", "MICROSECOND", "MILLISECOND", "SECOND"]
    
  aggregation-strategy-pattern:
    pattern-name: "Aggregation Strategy Pattern"
    description: "Aggregate performance data using different strategies"
    aggregation-strategies: ["REAL_TIME", "BATCH", "WINDOWED", "STATISTICAL"]

# Quality assurance
quality-assurance:
  pattern-accuracy:
    - "Monitoring patterns must be accurate"
    - "Performance measurements must be precise"
    - "Aggregation methods must be correct"
    - "Analysis results must be reliable"
    
  monitoring-reliability:
    - "Performance monitoring must be consistent"
    - "Measurement overhead must be minimal"
    - "Data collection must be comprehensive"
    - "Analysis must be actionable"
    
  system-requirements:
    - "Monitoring must not significantly impact performance"
    - "Data storage must be efficient"
    - "Analysis must be timely"
    - "Reporting must be clear and useful"
